
./a.out:     file format elf64-x86-64


Disassembly of section .init:

0000000000400af0 <_init>:
  400af0:	48 83 ec 08          	sub    $0x8,%rsp
  400af4:	48 8b 05 fd 14 20 00 	mov    0x2014fd(%rip),%rax        # 601ff8 <_DYNAMIC+0x1f0>
  400afb:	48 85 c0             	test   %rax,%rax
  400afe:	74 05                	je     400b05 <_init+0x15>
  400b00:	e8 2b 01 00 00       	callq  400c30 <_ZNSo3putEc@plt+0x10>
  400b05:	48 83 c4 08          	add    $0x8,%rsp
  400b09:	c3                   	retq   

Disassembly of section .plt:

0000000000400b10 <_ZSt16__throw_bad_castv@plt-0x10>:
  400b10:	ff 35 f2 14 20 00    	pushq  0x2014f2(%rip)        # 602008 <_GLOBAL_OFFSET_TABLE_+0x8>
  400b16:	ff 25 f4 14 20 00    	jmpq   *0x2014f4(%rip)        # 602010 <_GLOBAL_OFFSET_TABLE_+0x10>
  400b1c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400b20 <_ZSt16__throw_bad_castv@plt>:
  400b20:	ff 25 f2 14 20 00    	jmpq   *0x2014f2(%rip)        # 602018 <_GLOBAL_OFFSET_TABLE_+0x18>
  400b26:	68 00 00 00 00       	pushq  $0x0
  400b2b:	e9 e0 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b30 <_Znam@plt>:
  400b30:	ff 25 ea 14 20 00    	jmpq   *0x2014ea(%rip)        # 602020 <_GLOBAL_OFFSET_TABLE_+0x20>
  400b36:	68 01 00 00 00       	pushq  $0x1
  400b3b:	e9 d0 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b40 <_ZdlPv@plt>:
  400b40:	ff 25 e2 14 20 00    	jmpq   *0x2014e2(%rip)        # 602028 <_GLOBAL_OFFSET_TABLE_+0x28>
  400b46:	68 02 00 00 00       	pushq  $0x2
  400b4b:	e9 c0 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b50 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>:
  400b50:	ff 25 da 14 20 00    	jmpq   *0x2014da(%rip)        # 602030 <_GLOBAL_OFFSET_TABLE_+0x30>
  400b56:	68 03 00 00 00       	pushq  $0x3
  400b5b:	e9 b0 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b60 <_ZNSt8ios_base4InitC1Ev@plt>:
  400b60:	ff 25 d2 14 20 00    	jmpq   *0x2014d2(%rip)        # 602038 <_GLOBAL_OFFSET_TABLE_+0x38>
  400b66:	68 04 00 00 00       	pushq  $0x4
  400b6b:	e9 a0 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b70 <__libc_start_main@plt>:
  400b70:	ff 25 ca 14 20 00    	jmpq   *0x2014ca(%rip)        # 602040 <_GLOBAL_OFFSET_TABLE_+0x40>
  400b76:	68 05 00 00 00       	pushq  $0x5
  400b7b:	e9 90 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b80 <_ZNSt6chrono3_V212system_clock3nowEv@plt>:
  400b80:	ff 25 c2 14 20 00    	jmpq   *0x2014c2(%rip)        # 602048 <_GLOBAL_OFFSET_TABLE_+0x48>
  400b86:	68 06 00 00 00       	pushq  $0x6
  400b8b:	e9 80 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400b90 <__cxa_atexit@plt>:
  400b90:	ff 25 ba 14 20 00    	jmpq   *0x2014ba(%rip)        # 602050 <_GLOBAL_OFFSET_TABLE_+0x50>
  400b96:	68 07 00 00 00       	pushq  $0x7
  400b9b:	e9 70 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400ba0 <_ZNSt8ios_base4InitD1Ev@plt>:
  400ba0:	ff 25 b2 14 20 00    	jmpq   *0x2014b2(%rip)        # 602058 <_GLOBAL_OFFSET_TABLE_+0x58>
  400ba6:	68 08 00 00 00       	pushq  $0x8
  400bab:	e9 60 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400bb0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_assignERKS4_@plt>:
  400bb0:	ff 25 aa 14 20 00    	jmpq   *0x2014aa(%rip)        # 602060 <_GLOBAL_OFFSET_TABLE_+0x60>
  400bb6:	68 09 00 00 00       	pushq  $0x9
  400bbb:	e9 50 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400bc0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>:
  400bc0:	ff 25 a2 14 20 00    	jmpq   *0x2014a2(%rip)        # 602068 <_GLOBAL_OFFSET_TABLE_+0x68>
  400bc6:	68 0a 00 00 00       	pushq  $0xa
  400bcb:	e9 40 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400bd0 <_ZNSo5flushEv@plt>:
  400bd0:	ff 25 9a 14 20 00    	jmpq   *0x20149a(%rip)        # 602070 <_GLOBAL_OFFSET_TABLE_+0x70>
  400bd6:	68 0b 00 00 00       	pushq  $0xb
  400bdb:	e9 30 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400be0 <__stack_chk_fail@plt>:
  400be0:	ff 25 92 14 20 00    	jmpq   *0x201492(%rip)        # 602078 <_GLOBAL_OFFSET_TABLE_+0x78>
  400be6:	68 0c 00 00 00       	pushq  $0xc
  400beb:	e9 20 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400bf0 <_ZNSo9_M_insertIdEERSoT_@plt>:
  400bf0:	ff 25 8a 14 20 00    	jmpq   *0x20148a(%rip)        # 602080 <_GLOBAL_OFFSET_TABLE_+0x80>
  400bf6:	68 0d 00 00 00       	pushq  $0xd
  400bfb:	e9 10 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400c00 <__gxx_personality_v0@plt>:
  400c00:	ff 25 82 14 20 00    	jmpq   *0x201482(%rip)        # 602088 <_GLOBAL_OFFSET_TABLE_+0x88>
  400c06:	68 0e 00 00 00       	pushq  $0xe
  400c0b:	e9 00 ff ff ff       	jmpq   400b10 <_init+0x20>

0000000000400c10 <_Unwind_Resume@plt>:
  400c10:	ff 25 7a 14 20 00    	jmpq   *0x20147a(%rip)        # 602090 <_GLOBAL_OFFSET_TABLE_+0x90>
  400c16:	68 0f 00 00 00       	pushq  $0xf
  400c1b:	e9 f0 fe ff ff       	jmpq   400b10 <_init+0x20>

0000000000400c20 <_ZNSo3putEc@plt>:
  400c20:	ff 25 72 14 20 00    	jmpq   *0x201472(%rip)        # 602098 <_GLOBAL_OFFSET_TABLE_+0x98>
  400c26:	68 10 00 00 00       	pushq  $0x10
  400c2b:	e9 e0 fe ff ff       	jmpq   400b10 <_init+0x20>

Disassembly of section .plt.got:

0000000000400c30 <.plt.got>:
  400c30:	ff 25 c2 13 20 00    	jmpq   *0x2013c2(%rip)        # 601ff8 <_DYNAMIC+0x1f0>
  400c36:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

0000000000400c40 <main>:
#include <iostream>
#include <chrono>
#include "ProfileCpu.h" 
#include <complex>
int main()
{
  400c40:	41 57                	push   %r15
  400c42:	41 56                	push   %r14
  400c44:	41 55                	push   %r13
  400c46:	41 54                	push   %r12
  400c48:	55                   	push   %rbp
  400c49:	53                   	push   %rbx
  400c4a:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
	int i,j, nz, nx, l1, l2, l3, l4;
	nz = 32;
	nx = 64;
	ProfileCpu prof;
  400c51:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
#include <iostream>
#include <chrono>
#include "ProfileCpu.h" 
#include <complex>
int main()
{
  400c56:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  400c5d:	00 00 
  400c5f:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
  400c64:	31 c0                	xor    %eax,%eax
	int i,j, nz, nx, l1, l2, l3, l4;
	nz = 32;
	nx = 64;
	ProfileCpu prof;
  400c66:	e8 55 07 00 00       	callq  4013c0 <_ZN10ProfileCpuC1Ev>
	
	double *dW, *prod;
	std::complex<double> **matA;
	matA = new std::complex<double>*[nx];
  400c6b:	bf 00 02 00 00       	mov    $0x200,%edi
  400c70:	e8 bb fe ff ff       	callq  400b30 <_Znam@plt>
	dW = new double[nz*nx];
  400c75:	bf 00 40 00 00       	mov    $0x4000,%edi
	nx = 64;
	ProfileCpu prof;
	
	double *dW, *prod;
	std::complex<double> **matA;
	matA = new std::complex<double>*[nx];
  400c7a:	49 89 c7             	mov    %rax,%r15
	dW = new double[nz*nx];
  400c7d:	e8 ae fe ff ff       	callq  400b30 <_Znam@plt>
	prod = new double[nz*nx];
  400c82:	bf 00 40 00 00       	mov    $0x4000,%edi
	ProfileCpu prof;
	
	double *dW, *prod;
	std::complex<double> **matA;
	matA = new std::complex<double>*[nx];
	dW = new double[nz*nx];
  400c87:	48 89 c5             	mov    %rax,%rbp
	prod = new double[nz*nx];
  400c8a:	e8 a1 fe ff ff       	callq  400b30 <_Znam@plt>
	std::complex<double> *dummy = new std::complex<double>[nx];
  400c8f:	bf 00 04 00 00       	mov    $0x400,%edi
  400c94:	e8 97 fe ff ff       	callq  400b30 <_Znam@plt>
  400c99:	48 8d 98 00 04 00 00 	lea    0x400(%rax),%rbx
  400ca0:	49 89 c4             	mov    %rax,%r12

      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }

      _GLIBCXX_CONSTEXPR complex(double __r = 0.0, double __i = 0.0)
#if __cplusplus >= 201103L
      : _M_value{ __r, __i } { }
  400ca3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  400caa:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  400cb1:	00 
  400cb2:	48 83 c0 10          	add    $0x10,%rax
  400cb6:	48 39 d8             	cmp    %rbx,%rax
  400cb9:	75 e8                	jne    400ca3 <main+0x63>
  400cbb:	4d 8d af 00 02 00 00 	lea    0x200(%r15),%r13
  400cc2:	4d 89 fe             	mov    %r15,%r14
	
	for (i=0;i<nx;i++)
		matA[i] = new std::complex<double>[nz*nx];
  400cc5:	bf 00 80 00 00       	mov    $0x8000,%edi
  400cca:	e8 61 fe ff ff       	callq  400b30 <_Znam@plt>
  400ccf:	48 8d 88 00 80 00 00 	lea    0x8000(%rax),%rcx
  400cd6:	48 89 c2             	mov    %rax,%rdx
  400cd9:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  400ce0:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  400ce7:	00 
  400ce8:	48 83 c2 10          	add    $0x10,%rdx
  400cec:	48 39 d1             	cmp    %rdx,%rcx
  400cef:	75 e8                	jne    400cd9 <main+0x99>
  400cf1:	49 89 06             	mov    %rax,(%r14)
  400cf4:	49 83 c6 08          	add    $0x8,%r14
	matA = new std::complex<double>*[nx];
	dW = new double[nz*nx];
	prod = new double[nz*nx];
	std::complex<double> *dummy = new std::complex<double>[nx];
	
	for (i=0;i<nx;i++)
  400cf8:	4d 39 f5             	cmp    %r14,%r13
  400cfb:	75 c8                	jne    400cc5 <main+0x85>
  400cfd:	4c 89 fa             	mov    %r15,%rdx
  400d00:	48 8b 02             	mov    (%rdx),%rax
  400d03:	f2 0f 10 2d ed 07 00 	movsd  0x7ed(%rip),%xmm5        # 4014f8 <_IO_stdin_used+0x8>
  400d0a:	00 
  400d0b:	48 8d 88 00 80 00 00 	lea    0x8000(%rax),%rcx
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
	_M_value = __d;
  400d12:	f2 0f 11 28          	movsd  %xmm5,(%rax)
  400d16:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  400d1d:	00 
  400d1e:	48 83 c0 10          	add    $0x10,%rax
		matA[i] = new std::complex<double>[nz*nx];
		
	for (i=0;i<nx;i++)
	{
		for (j=0;j<nz*nx;j++)
  400d22:	48 39 c1             	cmp    %rax,%rcx
  400d25:	75 eb                	jne    400d12 <main+0xd2>
  400d27:	48 83 c2 08          	add    $0x8,%rdx
	std::complex<double> *dummy = new std::complex<double>[nx];
	
	for (i=0;i<nx;i++)
		matA[i] = new std::complex<double>[nz*nx];
		
	for (i=0;i<nx;i++)
  400d2b:	4c 39 ea             	cmp    %r13,%rdx
  400d2e:	75 d0                	jne    400d00 <main+0xc0>
  400d30:	40 f6 c5 08          	test   $0x8,%bpl
  400d34:	0f 84 52 03 00 00    	je     40108c <main+0x44c>
			matA[i][j] = 1;		
	}
	
	for (j=0;j<nz*nx;j++)
	{
		dW[j] = 1;		
  400d3a:	f2 0f 11 6d 00       	movsd  %xmm5,0x0(%rbp)
	{
		for (j=0;j<nz*nx;j++)
			matA[i][j] = 1;		
	}
	
	for (j=0;j<nz*nx;j++)
  400d3f:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		dW[j] = 1;		
  400d44:	b9 01 00 00 00       	mov    $0x1,%ecx
  400d49:	bf ff 07 00 00       	mov    $0x7ff,%edi
  400d4e:	41 b8 ff 03 00 00    	mov    $0x3ff,%r8d
  400d54:	ba fe 07 00 00       	mov    $0x7fe,%edx
  400d59:	48 8d 74 cd 00       	lea    0x0(%rbp,%rcx,8),%rsi
	std::complex<double> *dummy = new std::complex<double>[nx];
	
	for (i=0;i<nx;i++)
		matA[i] = new std::complex<double>[nz*nx];
		
	for (i=0;i<nx;i++)
  400d5e:	31 c9                	xor    %ecx,%ecx
  400d60:	66 0f 28 05 98 07 00 	movapd 0x798(%rip),%xmm0        # 401500 <_IO_stdin_used+0x10>
  400d67:	00 
  400d68:	83 c1 01             	add    $0x1,%ecx
  400d6b:	48 83 c6 10          	add    $0x10,%rsi
			matA[i][j] = 1;		
	}
	
	for (j=0;j<nz*nx;j++)
	{
		dW[j] = 1;		
  400d6f:	0f 29 46 f0          	movaps %xmm0,-0x10(%rsi)
  400d73:	41 39 c8             	cmp    %ecx,%r8d
  400d76:	77 f0                	ja     400d68 <main+0x128>
  400d78:	01 d0                	add    %edx,%eax
  400d7a:	39 fa                	cmp    %edi,%edx
  400d7c:	74 10                	je     400d8e <main+0x14e>
  400d7e:	f2 0f 10 3d 72 07 00 	movsd  0x772(%rip),%xmm7        # 4014f8 <_IO_stdin_used+0x8>
  400d85:	00 
  400d86:	48 98                	cltq   
  400d88:	f2 0f 11 7c c5 00    	movsd  %xmm7,0x0(%rbp,%rax,8)

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : allocator_type // TODO check __is_final
      {
	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
	: allocator_type(__a), _M_p(__dat) { }
  400d8e:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
	if (__n == 0)
	  return __s1;
	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
  400d93:	ba 74 72 00 00       	mov    $0x7274,%edx
	}
		
	prof.StartRegion("try");
  400d98:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  400d9d:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
  400da2:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
  400da7:	c6 40 02 79          	movb   $0x79,0x2(%rax)
  400dab:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }
  400db0:	48 c7 44 24 28 03 00 	movq   $0x3,0x28(%rsp)
  400db7:	00 00 
      typedef streamoff         off_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { __c1 = __c2; }
  400db9:	c6 44 24 33 00       	movb   $0x0,0x33(%rsp)
  400dbe:	e8 ed 04 00 00       	callq  4012b0 <_ZN10ProfileCpu11StartRegionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>
  400dc3:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
	if (!_M_is_local())
  400dc8:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
  400dcd:	48 39 c7             	cmp    %rax,%rdi
  400dd0:	74 05                	je     400dd7 <main+0x197>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
  400dd2:	e8 69 fd ff ff       	callq  400b40 <_ZdlPv@plt>
	
	std::complex<double> *p_prod = new std::complex<double>[nx*nz];
  400dd7:	bf 00 80 00 00       	mov    $0x8000,%edi
  400ddc:	e8 4f fd ff ff       	callq  400b30 <_Znam@plt>
  400de1:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  400de8:	49 89 c3             	mov    %rax,%r11

      _GLIBCXX_CONSTEXPR complex(_ComplexT __z) : _M_value(__z) { }

      _GLIBCXX_CONSTEXPR complex(double __r = 0.0, double __i = 0.0)
#if __cplusplus >= 201103L
      : _M_value{ __r, __i } { }
  400deb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  400df2:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  400df9:	00 
  400dfa:	48 83 c0 10          	add    $0x10,%rax
  400dfe:	48 39 d0             	cmp    %rdx,%rax
  400e01:	75 e8                	jne    400deb <main+0x1ab>
  400e03:	4d 8d b3 00 04 00 00 	lea    0x400(%r11),%r14
  400e0a:	4c 89 d8             	mov    %r11,%rax
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
	_M_value = __d;
  400e0d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  400e14:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  400e1b:	00 
  400e1c:	48 83 c0 10          	add    $0x10,%rax
	for(int i=0; i < nx; i++) 
  400e20:	4c 39 f0             	cmp    %r14,%rax
  400e23:	75 e8                	jne    400e0d <main+0x1cd>
  400e25:	66 0f ef e4          	pxor   %xmm4,%xmm4
  400e29:	48 89 2c 24          	mov    %rbp,(%rsp)
  400e2d:	45 31 c9             	xor    %r9d,%r9d
  400e30:	45 31 ed             	xor    %r13d,%r13d
  400e33:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
  400e38:	45 85 ed             	test   %r13d,%r13d
  400e3b:	44 89 e8             	mov    %r13d,%eax
  400e3e:	48 8b 0c 24          	mov    (%rsp),%rcx
  400e42:	0f 95 44 24 17       	setne  0x17(%rsp)
  400e47:	c1 e0 07             	shl    $0x7,%eax
  400e4a:	47 8d 54 2d 00       	lea    0x0(%r13,%r13,1),%r10d
  400e4f:	89 44 24 0c          	mov    %eax,0xc(%rsp)
  400e53:	41 8d 45 20          	lea    0x20(%r13),%eax
  400e57:	4c 89 dd             	mov    %r11,%rbp
  400e5a:	89 44 24 10          	mov    %eax,0x10(%rsp)
  400e5e:	48 89 ee             	mov    %rbp,%rsi
  400e61:	4c 89 e7             	mov    %r12,%rdi
  400e64:	4d 89 f8             	mov    %r15,%r8
  400e67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  400e6e:	00 00 
  400e70:	4c 89 ca             	mov    %r9,%rdx
  400e73:	49 03 10             	add    (%r8),%rdx
	      l2 = j*nx;
	      l3 = l1 + l2;

	      for(int k=0; k<nx; k++)
	      {
		  const std::complex<double> *p_Gxx = matA[k];
  400e76:	31 c0                	xor    %eax,%eax
  400e78:	66 0f 28 d4          	movapd %xmm4,%xmm2
  400e7c:	66 0f 28 cc          	movapd %xmm4,%xmm1
  400e80:	f2 0f 10 04 01       	movsd  (%rcx,%rax,1),%xmm0

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400e85:	f2 0f 10 1c 42       	movsd  (%rdx,%rax,2),%xmm3
  400e8a:	f2 0f 59 d8          	mulsd  %xmm0,%xmm3
	  __imag__ _M_value += __z.imag();
  400e8e:	f2 0f 59 44 42 08    	mulsd  0x8(%rdx,%rax,2),%xmm0
  400e94:	48 83 c0 08          	add    $0x8,%rax
		  dummy[k] = 0;

		  for(int l=0; l<nx; l++)
  400e98:	48 3d 00 02 00 00    	cmp    $0x200,%rax

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400e9e:	f2 0f 58 d3          	addsd  %xmm3,%xmm2
	  __imag__ _M_value += __z.imag();
  400ea2:	f2 0f 58 c8          	addsd  %xmm0,%xmm1
  400ea6:	75 d8                	jne    400e80 <main+0x240>
  400ea8:	f2 0f 11 17          	movsd  %xmm2,(%rdi)

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400eac:	f2 0f 58 16          	addsd  (%rsi),%xmm2
  400eb0:	48 83 c7 10          	add    $0x10,%rdi
  400eb4:	f2 0f 11 4f f8       	movsd  %xmm1,-0x8(%rdi)
	  __imag__ _M_value += __z.imag();
  400eb9:	f2 0f 58 4e 08       	addsd  0x8(%rsi),%xmm1
  400ebe:	49 83 c0 08          	add    $0x8,%r8
  400ec2:	48 83 c6 10          	add    $0x10,%rsi

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400ec6:	f2 0f 11 56 f0       	movsd  %xmm2,-0x10(%rsi)
	  __imag__ _M_value += __z.imag();
  400ecb:	f2 0f 11 4e f8       	movsd  %xmm1,-0x8(%rsi)
	  for (int j=0; j < nz-i; j++)
	  {
	      l2 = j*nx;
	      l3 = l1 + l2;

	      for(int k=0; k<nx; k++)
  400ed0:	48 39 fb             	cmp    %rdi,%rbx
  400ed3:	75 9b                	jne    400e70 <main+0x230>
		      dummy[k] += p_Gxx[ l1 + l ] * dW[ l3 + l ];

		  p_prod[ l2 + k ] += dummy[k];
	      }

	      if ( (2*i + j < nz) && (i>0) )
  400ed5:	41 83 fa 1f          	cmp    $0x1f,%r10d
  400ed9:	7f 34                	jg     400f0f <main+0x2cf>
  400edb:	80 7c 24 17 00       	cmpb   $0x0,0x17(%rsp)
  400ee0:	74 2d                	je     400f0f <main+0x2cf>
  400ee2:	48 63 54 24 0c       	movslq 0xc(%rsp),%rdx
  400ee7:	31 c0                	xor    %eax,%eax
  400ee9:	48 c1 e2 04          	shl    $0x4,%rdx
  400eed:	4c 01 da             	add    %r11,%rdx

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400ef0:	66 0f 10 0c 02       	movupd (%rdx,%rax,1),%xmm1
#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 387. std::complex over-encapsulated.
      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double 
      real() const { return __real__ _M_value; }
  400ef5:	66 41 0f 10 04 04    	movupd (%r12,%rax,1),%xmm0

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400efb:	66 0f 58 c1          	addpd  %xmm1,%xmm0
  400eff:	0f 11 04 02          	movups %xmm0,(%rdx,%rax,1)
  400f03:	48 83 c0 10          	add    $0x10,%rax
  400f07:	48 3d 00 04 00 00    	cmp    $0x400,%rax
  400f0d:	75 e1                	jne    400ef0 <main+0x2b0>
  400f0f:	41 83 c2 01          	add    $0x1,%r10d
  400f13:	83 44 24 0c 40       	addl   $0x40,0xc(%rsp)
  400f18:	48 81 c1 00 02 00 00 	add    $0x200,%rcx
  400f1f:	48 81 c5 00 04 00 00 	add    $0x400,%rbp
	
	
	for(int i=0; i < nz; i++)
	{
	  l1 = i*nx;
	  for (int j=0; j < nz-i; j++)
  400f26:	44 39 54 24 10       	cmp    %r10d,0x10(%rsp)
  400f2b:	0f 85 2d ff ff ff    	jne    400e5e <main+0x21e>
	for(int i=0; i < nx; i++) 
		p_prod[i] = 0;
		
	
	
	for(int i=0; i < nz; i++)
  400f31:	41 83 c5 01          	add    $0x1,%r13d
  400f35:	49 81 c1 00 04 00 00 	add    $0x400,%r9
  400f3c:	48 81 04 24 00 02 00 	addq   $0x200,(%rsp)
  400f43:	00 
  400f44:	41 83 fd 20          	cmp    $0x20,%r13d
  400f48:	0f 85 ea fe ff ff    	jne    400e38 <main+0x1f8>
  400f4e:	48 8b 6c 24 18       	mov    0x18(%rsp),%rbp
  400f53:	bf 00 04 00 00       	mov    $0x400,%edi
  400f58:	41 b8 01 00 00 00    	mov    $0x1,%r8d
	}


	for(int i=1; i < nz; i++)
	{
	  if (i <= nz-i)
  400f5e:	41 bb 20 00 00 00    	mov    $0x20,%r11d
  400f64:	41 ba 1f 00 00 00    	mov    $0x1f,%r10d
  400f6a:	4c 8d 8d 00 02 00 00 	lea    0x200(%rbp),%r9
  400f71:	44 89 d8             	mov    %r11d,%eax
  400f74:	44 29 c0             	sub    %r8d,%eax
  400f77:	44 39 c0             	cmp    %r8d,%eax
  400f7a:	0f 8c 3e 01 00 00    	jl     4010be <main+0x47e>
  400f80:	48 89 e9             	mov    %rbp,%rcx
  400f83:	4c 89 f6             	mov    %r14,%rsi
  400f86:	4c 8d a6 00 04 00 00 	lea    0x400(%rsi),%r12
  400f8d:	4c 89 fb             	mov    %r15,%rbx
  400f90:	48 89 fa             	mov    %rdi,%rdx
  400f93:	48 03 13             	add    (%rbx),%rdx
		  l2 = j*nx;
		  l3 = l1 + l2;

		  for(int k=0; k<nx; k++)
		  {
		      const std::complex<double> *p_Gxx = matA[k];
  400f96:	31 c0                	xor    %eax,%eax
  400f98:	f2 0f 10 16          	movsd  (%rsi),%xmm2
  400f9c:	f2 0f 10 4e 08       	movsd  0x8(%rsi),%xmm1
  400fa1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  400fa8:	f2 0f 10 04 01       	movsd  (%rcx,%rax,1),%xmm0
  400fad:	f2 0f 10 1c 42       	movsd  (%rdx,%rax,2),%xmm3
  400fb2:	f2 0f 59 d8          	mulsd  %xmm0,%xmm3
	  __imag__ _M_value += __z.imag();
  400fb6:	f2 0f 59 44 42 08    	mulsd  0x8(%rdx,%rax,2),%xmm0
  400fbc:	48 83 c0 08          	add    $0x8,%rax
		      for(int l=0; l<nx; l++)
  400fc0:	48 3d 00 02 00 00    	cmp    $0x200,%rax

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  400fc6:	f2 0f 58 d3          	addsd  %xmm3,%xmm2
	  __imag__ _M_value += __z.imag();
  400fca:	f2 0f 58 c8          	addsd  %xmm0,%xmm1
  400fce:	75 d8                	jne    400fa8 <main+0x368>
  400fd0:	f2 0f 11 16          	movsd  %xmm2,(%rsi)
  400fd4:	48 83 c6 10          	add    $0x10,%rsi
  400fd8:	48 83 c3 08          	add    $0x8,%rbx
  400fdc:	f2 0f 11 4e f8       	movsd  %xmm1,-0x8(%rsi)
	      for (int j=0; j < i; j++)
	      {
		  l2 = j*nx;
		  l3 = l1 + l2;

		  for(int k=0; k<nx; k++)
  400fe1:	4c 39 e6             	cmp    %r12,%rsi
  400fe4:	75 aa                	jne    400f90 <main+0x350>
  400fe6:	48 81 c1 00 02 00 00 	add    $0x200,%rcx
	for(int i=1; i < nz; i++)
	{
	  if (i <= nz-i)
	  {
	      l1 = i*nx;
	      for (int j=0; j < i; j++)
  400fed:	49 39 c9             	cmp    %rcx,%r9
  400ff0:	75 94                	jne    400f86 <main+0x346>
	      }
	  }
	}


	for(int i=1; i < nz; i++)
  400ff2:	41 83 c0 01          	add    $0x1,%r8d
  400ff6:	49 81 c1 00 02 00 00 	add    $0x200,%r9
  400ffd:	48 81 c7 00 04 00 00 	add    $0x400,%rdi
  401004:	49 81 c6 00 04 00 00 	add    $0x400,%r14
  40100b:	41 83 f8 20          	cmp    $0x20,%r8d
  40100f:	0f 85 5c ff ff ff    	jne    400f71 <main+0x331>
		  }
	      }
	  }
	}

	prof.EndRegion();
  401015:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
  40101a:	e8 b1 02 00 00       	callq  4012d0 <_ZN10ProfileCpu9EndRegionEv>
  40101f:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  401024:	48 8d 44 24 68       	lea    0x68(%rsp),%rax
public:
    ProfileCpu();
	virtual void StartRegion(const std::string &name);
	virtual void EndRegion();

	virtual ~ProfileCpu() {}
  401029:	48 c7 44 24 40 68 15 	movq   $0x401568,0x40(%rsp)
  401030:	40 00 
  401032:	48 39 c7             	cmp    %rax,%rdi
  401035:	74 05                	je     40103c <main+0x3fc>
  401037:	e8 04 fb ff ff       	callq  400b40 <_ZdlPv@plt>
			
}
  40103c:	31 c0                	xor    %eax,%eax
  40103e:	48 8b 5c 24 78       	mov    0x78(%rsp),%rbx
  401043:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  40104a:	00 00 
  40104c:	0f 85 ed 00 00 00    	jne    40113f <main+0x4ff>
  401052:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  401059:	5b                   	pop    %rbx
  40105a:	5d                   	pop    %rbp
  40105b:	41 5c                	pop    %r12
  40105d:	41 5d                	pop    %r13
  40105f:	41 5e                	pop    %r14
  401061:	41 5f                	pop    %r15
  401063:	c3                   	retq   
  401064:	48 89 c3             	mov    %rax,%rbx
  401067:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  40106c:	48 8d 54 24 68       	lea    0x68(%rsp),%rdx
  401071:	48 c7 44 24 40 68 15 	movq   $0x401568,0x40(%rsp)
  401078:	40 00 
  40107a:	48 39 d7             	cmp    %rdx,%rdi
  40107d:	74 05                	je     401084 <main+0x444>
  40107f:	e8 bc fa ff ff       	callq  400b40 <_ZdlPv@plt>
  401084:	48 89 df             	mov    %rbx,%rdi
  401087:	e8 84 fb ff ff       	callq  400c10 <_Unwind_Resume@plt>
	std::complex<double> *dummy = new std::complex<double>[nx];
	
	for (i=0;i<nx;i++)
		matA[i] = new std::complex<double>[nz*nx];
		
	for (i=0;i<nx;i++)
  40108c:	31 c0                	xor    %eax,%eax
  40108e:	31 c9                	xor    %ecx,%ecx
  401090:	bf 00 08 00 00       	mov    $0x800,%edi
  401095:	41 b8 00 04 00 00    	mov    $0x400,%r8d
  40109b:	ba 00 08 00 00       	mov    $0x800,%edx
  4010a0:	e9 b4 fc ff ff       	jmpq   400d59 <main+0x119>
  4010a5:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  4010aa:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
  4010af:	48 89 c3             	mov    %rax,%rbx
  4010b2:	48 39 d7             	cmp    %rdx,%rdi
  4010b5:	74 b0                	je     401067 <main+0x427>
  4010b7:	e8 84 fa ff ff       	callq  400b40 <_ZdlPv@plt>
  4010bc:	eb a9                	jmp    401067 <main+0x427>
  4010be:	45 89 d4             	mov    %r10d,%r12d
	}


	for(int i=1; i < nz; i++)
	{
	  if (i <= nz-i)
  4010c1:	48 89 e9             	mov    %rbp,%rcx
  4010c4:	4c 89 f6             	mov    %r14,%rsi
  4010c7:	45 29 c4             	sub    %r8d,%r12d
  4010ca:	49 83 c4 01          	add    $0x1,%r12
  4010ce:	49 c1 e4 09          	shl    $0x9,%r12
  4010d2:	49 01 ec             	add    %rbp,%r12
  4010d5:	4c 8d ae 00 04 00 00 	lea    0x400(%rsi),%r13
  4010dc:	4c 89 fb             	mov    %r15,%rbx
  4010df:	48 89 fa             	mov    %rdi,%rdx
  4010e2:	48 03 13             	add    (%rbx),%rdx
		  l2 = j*nx;
		  l3 = l1 + l2;

		  for(int k=0; k<nx; k++)
		  {
		      const std::complex<double> *p_Gxx = matA[k];
  4010e5:	31 c0                	xor    %eax,%eax
  4010e7:	f2 0f 10 16          	movsd  (%rsi),%xmm2
  4010eb:	f2 0f 10 4e 08       	movsd  0x8(%rsi),%xmm1
  4010f0:	f2 0f 10 04 01       	movsd  (%rcx,%rax,1),%xmm0

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  4010f5:	f2 0f 10 1c 42       	movsd  (%rdx,%rax,2),%xmm3
  4010fa:	f2 0f 59 d8          	mulsd  %xmm0,%xmm3
	  __imag__ _M_value += __z.imag();
  4010fe:	f2 0f 59 44 42 08    	mulsd  0x8(%rdx,%rax,2),%xmm0
  401104:	48 83 c0 08          	add    $0x8,%rax

		      for(int l=0; l<nx; l++)
  401108:	48 3d 00 02 00 00    	cmp    $0x200,%rax

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
	{
	  __real__ _M_value += __z.real();
  40110e:	f2 0f 58 d3          	addsd  %xmm3,%xmm2
	  __imag__ _M_value += __z.imag();
  401112:	f2 0f 58 c8          	addsd  %xmm0,%xmm1
  401116:	75 d8                	jne    4010f0 <main+0x4b0>
  401118:	f2 0f 11 16          	movsd  %xmm2,(%rsi)
  40111c:	48 83 c6 10          	add    $0x10,%rsi
  401120:	48 83 c3 08          	add    $0x8,%rbx
  401124:	f2 0f 11 4e f8       	movsd  %xmm1,-0x8(%rsi)
	      for (int j=0; j < nz-i; j++)
	      {
		  l2 = j*nx;
		  l3 = l1 + l2;

		  for(int k=0; k<nx; k++)
  401129:	49 39 f5             	cmp    %rsi,%r13
  40112c:	75 b1                	jne    4010df <main+0x49f>
  40112e:	48 81 c1 00 02 00 00 	add    $0x200,%rcx
	      }
	  }
	  else
	  {
	      l1 = i*nx;
	      for (int j=0; j < nz-i; j++)
  401135:	49 39 cc             	cmp    %rcx,%r12
  401138:	75 9b                	jne    4010d5 <main+0x495>
  40113a:	e9 b3 fe ff ff       	jmpq   400ff2 <main+0x3b2>
	  }
	}

	prof.EndRegion();
			
}
  40113f:	e8 9c fa ff ff       	callq  400be0 <__stack_chk_fail@plt>
  401144:	66 90                	xchg   %ax,%ax
  401146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40114d:	00 00 00 

0000000000401150 <_GLOBAL__sub_I_main>:
  401150:	48 83 ec 08          	sub    $0x8,%rsp
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
  401154:	bf 31 22 60 00       	mov    $0x602231,%edi
  401159:	e8 02 fa ff ff       	callq  400b60 <_ZNSt8ios_base4InitC1Ev@plt>
  40115e:	ba a8 20 60 00       	mov    $0x6020a8,%edx
  401163:	be 31 22 60 00       	mov    $0x602231,%esi
  401168:	bf a0 0b 40 00       	mov    $0x400ba0,%edi
  40116d:	48 83 c4 08          	add    $0x8,%rsp
  401171:	e9 1a fa ff ff       	jmpq   400b90 <__cxa_atexit@plt>
  401176:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40117d:	00 00 00 

0000000000401180 <_GLOBAL__sub_I__ZN10ProfileCpuC2Ev>:

void ProfileCpu::EndRegion() {
    T_end = std::chrono::system_clock::now();
    std::chrono::duration<double> elapsed_secs = T_end - T_start;
    std::cout << "Computation time for " << regionname << " was " << elapsed_secs.count() << " seconds" << std::endl;
}
  401180:	48 83 ec 08          	sub    $0x8,%rsp
  401184:	bf 32 22 60 00       	mov    $0x602232,%edi
  401189:	e8 d2 f9 ff ff       	callq  400b60 <_ZNSt8ios_base4InitC1Ev@plt>
  40118e:	ba a8 20 60 00       	mov    $0x6020a8,%edx
  401193:	be 32 22 60 00       	mov    $0x602232,%esi
  401198:	bf a0 0b 40 00       	mov    $0x400ba0,%edi
  40119d:	48 83 c4 08          	add    $0x8,%rsp
  4011a1:	e9 ea f9 ff ff       	jmpq   400b90 <__cxa_atexit@plt>
  4011a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4011ad:	00 00 00 

00000000004011b0 <_start>:
  4011b0:	31 ed                	xor    %ebp,%ebp
  4011b2:	49 89 d1             	mov    %rdx,%r9
  4011b5:	5e                   	pop    %rsi
  4011b6:	48 89 e2             	mov    %rsp,%rdx
  4011b9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4011bd:	50                   	push   %rax
  4011be:	54                   	push   %rsp
  4011bf:	49 c7 c0 e0 14 40 00 	mov    $0x4014e0,%r8
  4011c6:	48 c7 c1 70 14 40 00 	mov    $0x401470,%rcx
  4011cd:	48 c7 c7 40 0c 40 00 	mov    $0x400c40,%rdi
  4011d4:	e8 97 f9 ff ff       	callq  400b70 <__libc_start_main@plt>
  4011d9:	f4                   	hlt    
  4011da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004011e0 <deregister_tm_clones>:
  4011e0:	b8 b7 20 60 00       	mov    $0x6020b7,%eax
  4011e5:	55                   	push   %rbp
  4011e6:	48 2d b0 20 60 00    	sub    $0x6020b0,%rax
  4011ec:	48 83 f8 0e          	cmp    $0xe,%rax
  4011f0:	48 89 e5             	mov    %rsp,%rbp
  4011f3:	76 1b                	jbe    401210 <deregister_tm_clones+0x30>
  4011f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4011fa:	48 85 c0             	test   %rax,%rax
  4011fd:	74 11                	je     401210 <deregister_tm_clones+0x30>
  4011ff:	5d                   	pop    %rbp
  401200:	bf b0 20 60 00       	mov    $0x6020b0,%edi
  401205:	ff e0                	jmpq   *%rax
  401207:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40120e:	00 00 
  401210:	5d                   	pop    %rbp
  401211:	c3                   	retq   
  401212:	0f 1f 40 00          	nopl   0x0(%rax)
  401216:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40121d:	00 00 00 

0000000000401220 <register_tm_clones>:
  401220:	be b0 20 60 00       	mov    $0x6020b0,%esi
  401225:	55                   	push   %rbp
  401226:	48 81 ee b0 20 60 00 	sub    $0x6020b0,%rsi
  40122d:	48 c1 fe 03          	sar    $0x3,%rsi
  401231:	48 89 e5             	mov    %rsp,%rbp
  401234:	48 89 f0             	mov    %rsi,%rax
  401237:	48 c1 e8 3f          	shr    $0x3f,%rax
  40123b:	48 01 c6             	add    %rax,%rsi
  40123e:	48 d1 fe             	sar    %rsi
  401241:	74 15                	je     401258 <register_tm_clones+0x38>
  401243:	b8 00 00 00 00       	mov    $0x0,%eax
  401248:	48 85 c0             	test   %rax,%rax
  40124b:	74 0b                	je     401258 <register_tm_clones+0x38>
  40124d:	5d                   	pop    %rbp
  40124e:	bf b0 20 60 00       	mov    $0x6020b0,%edi
  401253:	ff e0                	jmpq   *%rax
  401255:	0f 1f 00             	nopl   (%rax)
  401258:	5d                   	pop    %rbp
  401259:	c3                   	retq   
  40125a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401260 <__do_global_dtors_aux>:
  401260:	80 3d c9 0f 20 00 00 	cmpb   $0x0,0x200fc9(%rip)        # 602230 <completed.7585>
  401267:	75 11                	jne    40127a <__do_global_dtors_aux+0x1a>
  401269:	55                   	push   %rbp
  40126a:	48 89 e5             	mov    %rsp,%rbp
  40126d:	e8 6e ff ff ff       	callq  4011e0 <deregister_tm_clones>
  401272:	5d                   	pop    %rbp
  401273:	c6 05 b6 0f 20 00 01 	movb   $0x1,0x200fb6(%rip)        # 602230 <completed.7585>
  40127a:	f3 c3                	repz retq 
  40127c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401280 <frame_dummy>:
  401280:	bf 00 1e 60 00       	mov    $0x601e00,%edi
  401285:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  401289:	75 05                	jne    401290 <frame_dummy+0x10>
  40128b:	eb 93                	jmp    401220 <register_tm_clones>
  40128d:	0f 1f 00             	nopl   (%rax)
  401290:	b8 00 00 00 00       	mov    $0x0,%eax
  401295:	48 85 c0             	test   %rax,%rax
  401298:	74 f1                	je     40128b <frame_dummy+0xb>
  40129a:	55                   	push   %rbp
  40129b:	48 89 e5             	mov    %rsp,%rbp
  40129e:	ff d0                	callq  *%rax
  4012a0:	5d                   	pop    %rbp
  4012a1:	e9 7a ff ff ff       	jmpq   401220 <register_tm_clones>
  4012a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4012ad:	00 00 00 

00000000004012b0 <_ZN10ProfileCpu11StartRegionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>:
    : T_start(std::chrono::system_clock::now()), T_end(std::chrono::system_clock::now()), regionname("")
{

}

void ProfileCpu::StartRegion(const std::string &name) {
  4012b0:	53                   	push   %rbx
  4012b1:	48 89 fb             	mov    %rdi,%rbx
  regionname = name;
  4012b4:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
       *  @return  Reference to this string.
       */
      basic_string&
      assign(const basic_string& __str)
      {
	this->_M_assign(__str);
  4012b8:	e8 f3 f8 ff ff       	callq  400bb0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_assignERKS4_@plt>
  T_start = std::chrono::system_clock::now();
  4012bd:	e8 be f8 ff ff       	callq  400b80 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4012c2:	48 89 43 08          	mov    %rax,0x8(%rbx)
}
  4012c6:	5b                   	pop    %rbx
  4012c7:	c3                   	retq   
  4012c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4012cf:	00 

00000000004012d0 <_ZN10ProfileCpu9EndRegionEv>:

void ProfileCpu::EndRegion() {
  4012d0:	55                   	push   %rbp
  4012d1:	53                   	push   %rbx
  4012d2:	48 89 fb             	mov    %rdi,%rbx
  4012d5:	48 83 ec 18          	sub    $0x18,%rsp
    T_end = std::chrono::system_clock::now();
  4012d9:	e8 a2 f8 ff ff       	callq  400b80 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4012de:	48 89 43 10          	mov    %rax,0x10(%rbx)
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
  4012e2:	48 2b 43 08          	sub    0x8(%rbx),%rax
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  4012e6:	ba 15 00 00 00       	mov    $0x15,%edx
  4012eb:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4012ef:	be 10 15 40 00       	mov    $0x401510,%esi
  4012f4:	bf 20 21 60 00       	mov    $0x602120,%edi
  4012f9:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  4012fe:	f2 0f 5e 05 82 02 00 	divsd  0x282(%rip),%xmm0        # 401588 <_ZTV10ProfileCpu+0x30>
  401305:	00 
  401306:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  40130c:	e8 af f8 ff ff       	callq  400bc0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
    operator<<(basic_ostream<_CharT, _Traits>& __os,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
  401311:	48 8b 53 20          	mov    0x20(%rbx),%rdx
  401315:	bf 20 21 60 00       	mov    $0x602120,%edi
  40131a:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  40131e:	e8 9d f8 ff ff       	callq  400bc0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
  401323:	ba 05 00 00 00       	mov    $0x5,%edx
  401328:	be 26 15 40 00       	mov    $0x401526,%esi
  40132d:	48 89 c7             	mov    %rax,%rdi
  401330:	48 89 c3             	mov    %rax,%rbx
  401333:	e8 88 f8 ff ff       	callq  400bc0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  401338:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  40133e:	48 89 df             	mov    %rbx,%rdi
  401341:	e8 aa f8 ff ff       	callq  400bf0 <_ZNSo9_M_insertIdEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  401346:	ba 08 00 00 00       	mov    $0x8,%edx
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
  40134b:	48 89 c3             	mov    %rax,%rbx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
  40134e:	be 2c 15 40 00       	mov    $0x40152c,%esi
  401353:	48 89 c7             	mov    %rax,%rdi
  401356:	e8 65 f8 ff ff       	callq  400bc0 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l@plt>
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  40135b:	48 8b 03             	mov    (%rbx),%rax
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
  40135e:	48 8b 40 e8          	mov    -0x18(%rax),%rax
  401362:	48 8b ac 03 f0 00 00 	mov    0xf0(%rbx,%rax,1),%rbp
  401369:	00 

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
  40136a:	48 85 ed             	test   %rbp,%rbp
  40136d:	74 48                	je     4013b7 <_ZN10ProfileCpu9EndRegionEv+0xe7>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
  40136f:	80 7d 38 00          	cmpb   $0x0,0x38(%rbp)
  401373:	74 1b                	je     401390 <_ZN10ProfileCpu9EndRegionEv+0xc0>
  401375:	0f be 75 43          	movsbl 0x43(%rbp),%esi
  401379:	48 89 df             	mov    %rbx,%rdi
  40137c:	e8 9f f8 ff ff       	callq  400c20 <_ZNSo3putEc@plt>
    std::chrono::duration<double> elapsed_secs = T_end - T_start;
    std::cout << "Computation time for " << regionname << " was " << elapsed_secs.count() << " seconds" << std::endl;
}
  401381:	48 83 c4 18          	add    $0x18,%rsp
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  401385:	48 89 c7             	mov    %rax,%rdi
  401388:	5b                   	pop    %rbx
  401389:	5d                   	pop    %rbp
  40138a:	e9 41 f8 ff ff       	jmpq   400bd0 <_ZNSo5flushEv@plt>
  40138f:	90                   	nop
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
  401390:	48 89 ef             	mov    %rbp,%rdi
  401393:	e8 b8 f7 ff ff       	callq  400b50 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
  401398:	48 8b 45 00          	mov    0x0(%rbp),%rax
  40139c:	be 0a 00 00 00       	mov    $0xa,%esi
  4013a1:	48 8b 40 30          	mov    0x30(%rax),%rax
  4013a5:	48 3d 00 14 40 00    	cmp    $0x401400,%rax
  4013ab:	74 cc                	je     401379 <_ZN10ProfileCpu9EndRegionEv+0xa9>
  4013ad:	48 89 ef             	mov    %rbp,%rdi
  4013b0:	ff d0                	callq  *%rax
  4013b2:	0f be f0             	movsbl %al,%esi
  4013b5:	eb c2                	jmp    401379 <_ZN10ProfileCpu9EndRegionEv+0xa9>
	__throw_bad_cast();
  4013b7:	e8 64 f7 ff ff       	callq  400b20 <_ZSt16__throw_bad_castv@plt>
  4013bc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004013c0 <_ZN10ProfileCpuC1Ev>:
#include "ProfileCpu.h"

#include <string>

ProfileCpu::ProfileCpu()
  4013c0:	53                   	push   %rbx
    : T_start(std::chrono::system_clock::now()), T_end(std::chrono::system_clock::now()), regionname("")
  4013c1:	48 c7 07 68 15 40 00 	movq   $0x401568,(%rdi)
#include "ProfileCpu.h"

#include <string>

ProfileCpu::ProfileCpu()
  4013c8:	48 89 fb             	mov    %rdi,%rbx
    : T_start(std::chrono::system_clock::now()), T_end(std::chrono::system_clock::now()), regionname("")
  4013cb:	e8 b0 f7 ff ff       	callq  400b80 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4013d0:	48 89 43 08          	mov    %rax,0x8(%rbx)
  4013d4:	e8 a7 f7 ff ff       	callq  400b80 <_ZNSt6chrono3_V212system_clock3nowEv@plt>
  4013d9:	48 89 43 10          	mov    %rax,0x10(%rbx)

      pointer
      _M_local_data()
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
  4013dd:	48 8d 43 28          	lea    0x28(%rbx),%rax
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }
  4013e1:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  4013e8:	00 
  4013e9:	c6 43 28 00          	movb   $0x0,0x28(%rbx)

      pointer
      _M_local_data()
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
  4013ed:	48 89 43 18          	mov    %rax,0x18(%rbx)
{

}
  4013f1:	5b                   	pop    %rbx
  4013f2:	c3                   	retq   
  4013f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4013fa:	00 00 00 
  4013fd:	0f 1f 00             	nopl   (%rax)

0000000000401400 <_ZNKSt5ctypeIcE8do_widenEc>:
       *  @param __c  The char to convert.
       *  @return  The converted character.
      */
      virtual char_type
      do_widen(char __c) const
      { return __c; }
  401400:	89 f0                	mov    %esi,%eax
  401402:	c3                   	retq   
  401403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40140a:	00 00 00 
  40140d:	0f 1f 00             	nopl   (%rax)

0000000000401410 <_ZN10ProfileCpuD1Ev>:
  401410:	48 89 f8             	mov    %rdi,%rax
  401413:	48 c7 07 68 15 40 00 	movq   $0x401568,(%rdi)
  40141a:	48 8b 7f 18          	mov    0x18(%rdi),%rdi

      const_pointer
      _M_local_data() const
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
  40141e:	48 83 c0 28          	add    $0x28,%rax
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
	if (!_M_is_local())
  401422:	48 39 c7             	cmp    %rax,%rdi
  401425:	74 09                	je     401430 <_ZN10ProfileCpuD1Ev+0x20>
  401427:	e9 14 f7 ff ff       	jmpq   400b40 <_ZdlPv@plt>
  40142c:	0f 1f 40 00          	nopl   0x0(%rax)
  401430:	f3 c3                	repz retq 
  401432:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  401439:	00 00 00 
  40143c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401440 <_ZN10ProfileCpuD0Ev>:
  401440:	53                   	push   %rbx
  401441:	48 89 fb             	mov    %rdi,%rbx
  401444:	48 c7 07 68 15 40 00 	movq   $0x401568,(%rdi)
  40144b:	48 8b 7f 18          	mov    0x18(%rdi),%rdi

      const_pointer
      _M_local_data() const
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
  40144f:	48 8d 43 28          	lea    0x28(%rbx),%rax
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
	if (!_M_is_local())
  401453:	48 39 c7             	cmp    %rax,%rdi
  401456:	74 05                	je     40145d <_ZN10ProfileCpuD0Ev+0x1d>
  401458:	e8 e3 f6 ff ff       	callq  400b40 <_ZdlPv@plt>
  40145d:	48 89 df             	mov    %rbx,%rdi
  401460:	5b                   	pop    %rbx
  401461:	e9 da f6 ff ff       	jmpq   400b40 <_ZdlPv@plt>
  401466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40146d:	00 00 00 

0000000000401470 <__libc_csu_init>:
  401470:	41 57                	push   %r15
  401472:	41 56                	push   %r14
  401474:	41 89 ff             	mov    %edi,%r15d
  401477:	41 55                	push   %r13
  401479:	41 54                	push   %r12
  40147b:	4c 8d 25 5e 09 20 00 	lea    0x20095e(%rip),%r12        # 601de0 <__frame_dummy_init_array_entry>
  401482:	55                   	push   %rbp
  401483:	48 8d 2d 6e 09 20 00 	lea    0x20096e(%rip),%rbp        # 601df8 <__init_array_end>
  40148a:	53                   	push   %rbx
  40148b:	49 89 f6             	mov    %rsi,%r14
  40148e:	49 89 d5             	mov    %rdx,%r13
  401491:	4c 29 e5             	sub    %r12,%rbp
  401494:	48 83 ec 08          	sub    $0x8,%rsp
  401498:	48 c1 fd 03          	sar    $0x3,%rbp
  40149c:	e8 4f f6 ff ff       	callq  400af0 <_init>
  4014a1:	48 85 ed             	test   %rbp,%rbp
  4014a4:	74 20                	je     4014c6 <__libc_csu_init+0x56>
  4014a6:	31 db                	xor    %ebx,%ebx
  4014a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4014af:	00 
  4014b0:	4c 89 ea             	mov    %r13,%rdx
  4014b3:	4c 89 f6             	mov    %r14,%rsi
  4014b6:	44 89 ff             	mov    %r15d,%edi
  4014b9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  4014bd:	48 83 c3 01          	add    $0x1,%rbx
  4014c1:	48 39 eb             	cmp    %rbp,%rbx
  4014c4:	75 ea                	jne    4014b0 <__libc_csu_init+0x40>
  4014c6:	48 83 c4 08          	add    $0x8,%rsp
  4014ca:	5b                   	pop    %rbx
  4014cb:	5d                   	pop    %rbp
  4014cc:	41 5c                	pop    %r12
  4014ce:	41 5d                	pop    %r13
  4014d0:	41 5e                	pop    %r14
  4014d2:	41 5f                	pop    %r15
  4014d4:	c3                   	retq   
  4014d5:	90                   	nop
  4014d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4014dd:	00 00 00 

00000000004014e0 <__libc_csu_fini>:
  4014e0:	f3 c3                	repz retq 

Disassembly of section .fini:

00000000004014e4 <_fini>:
  4014e4:	48 83 ec 08          	sub    $0x8,%rsp
  4014e8:	48 83 c4 08          	add    $0x8,%rsp
  4014ec:	c3                   	retq   
