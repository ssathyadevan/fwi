\documentclass[10pt,a4paper]{article}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsthm,amsfonts,mathrsfs}
\usepackage{enumerate}
\usepackage{amsmath,accents}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{subfigure}
\usepackage{hyperref}
\usepackage{nomencl}


\setlength{\parindent}{0pt}

\newcommand{\nomunit}[1]{\renewcommand{\nomentryend}{\hspace*{\fill}#1}}

\newcommand{\partder}[2]{\ensuremath{\frac{\partial #1}{\partial #2}}}
\newcommand{\secpartder}[2]{\ensuremath{\frac{\partial^2 #1}{\partial #2^2}}}
\newcommand{\nthpartder}[3]{\ensuremath{\frac{\partial^{#1} #2}{\partial #3^{#1}}}}
\newcommand{\fullder}[2]{\ensuremath{\frac{\mbox{d} #1}{\mbox{d} #2}}}
\newcommand{\secfullder}[2]{\ensuremath{\frac{\mbox{d}^2 #1}{\mbox{d} #2^2}}}
\newcommand{\nfullder}[3]{\ensuremath{\frac{\mbox{d}^{#1} #2}{\mbox{d} #3^{#1}}}}
\newcommand{\mixedder}[3]{\ensuremath{\frac{\partial^{2} #1}{\partial #2 \partial #3}}}
\newcommand{\df}[1]{\, \ensuremath{\mbox{d}#1}}
\newcommand{\grad}{\, \mbox{grad} \,}
\newcommand{\dive}{\, \mbox{div} \,}
\newcommand{\real}[1]{\text{Re} \left\{ #1 \right\}}
\newcommand{\imag}[1]{\text{Im}\left\{ #1 \right\}}

\newcommand{\xs}{\mathbf{x}_\text{s}}
\newcommand{\xr}{\mathbf{x}_\text{r}}
\newcommand{\x}{\mathbf{x}}

\newtheorem{thm}{Theorem}[section]
\makenomenclature
%opening

\title{Full Waveform Inversion}
\author{ALTEN Netherlands}


\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}

The Full Wave inversion is a complex imaging technique which can be achieved by illuminating the interior of the object with e.g. acoustic or electromagnetic waves, while receivers placed around the object measure the response. From these measurements an image of the properties of the object's interior can be derived.

It has various applications including,
 
\begin{enumerate}
    \item seismology
    \item medical: ultrasonic applications
\end{enumerate}

\begin{figure}
  \includegraphics[width=\linewidth]{FWI1.png}
  \caption{Seismic Full Waveform Inversion}
  \label{fig:FWI1}
\end{figure}

Figure \ref{fig:FWI1} displays the perspective views of Axial Volcanoâ€™s internal structure, constructed using elastic full waveform inversion (FWI) results along seismic lines across caldera and along the secondary magma reservoir. (a): P-wave velocity structure. (b): Total gradient magnitude of the P-wave velocity structure. (c) Reflectivity structure. The red mesh marks the extent of the main magma reservoir on (a) and (b).

In FWI, the aim is to find the media properties on a dense subsurface grid, instead of image amplitudes. Synthetic seismic data are forward modeled and compared with the measured dataset. The differences are then used to update the full set of media properties and the process is repeated until a satisfactory match between modeled and measured dataset is obtained. In Figure \ref{fig:FWI2} flow chart for the process is shown. It can be seen that, in contrast to imaging techniques, a closed loop exists, meaning that feedback from the obtained media properties is used to verify any inconsistency between the measured data and the inversion result. In the flow chart we can see that we begin with forward modelling and estimate the synthetic data. Further, we iterate the data in order to minimise the residuals as compared to the real data and obtain the final data once the residuals are below the specified tolerance levels.


\begin{figure}
  \includegraphics[width=\linewidth]{FWI2.png}
  \caption{Full Waveform Inversion Methodology}
  \label{fig:FWI2}
\end{figure}

This document explains an overview of the equations employed, the computational model and the code algorithm.

\section{Mathematical Model}

The mathematical model outlines the equations used in the code for the FWI. We begin with the Green's function and apply it to the  the simplest acoustic equation - the Helmholtz equation. 
For the acoustic case with constant density, the wave equation can be described by a set of two couples equations, being the data equation and the object equation. The data equation describes the seismic dataset, in terms of a total field $p_{\text{tot}}$ at each grid point int he subsurface, the contrast function $\chi$ and the Green's function $G$ in a background medium:

\begin{equation} \label{eq:eq1}
p_\text{data}(\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) = \int \mathcal{G}(\xr, \x, \omega) p_\text{tot}(\x, \xs, \omega) \chi(\x) \df{\x} \end{equation}

Reading from right to left, equation \ref{eq:eq1} can be understood as follows: A source transmits a wavefield that propagates to every point in the subsurface. Note that this wavefield $p_\text{tot}$ is generally quite complex because it takes the interaction of all scatterers in the subsurface already into account. This wavefield is creating secondary sources in all points where the contrast function $\chi$ is non-zero. The secondary sources transmit energy through a smooth background medium to the receivers, represented by the Green's function G in equation \ref{eq:eq1}. \linebreak 
\newline
The measured seismic data at every receiver are then a summation of all secondary sources. It should be mentioned that direct waves, including ground roll and surface waves are supposed to be removed from the measured data to obtain $p_\text{data}$.
\newline

We use the 2-D case for the Helmholtz equation. Further, the Green's function is calculated for this equation. The contrast function has to be determined. Further the conjugate scheme is established to determine the error functional. 
\newline

Measured seismic data always contains some form of noise, so the inversion process is required to be regularised. Therefore, we extend the conjugate gradient scheme in a way that it contains a multiplicative regularisation factor. 

\subsection{The Green's function}
A Green's function is the impulse response of an inhomogeneous linear differential equation defined on a domain, with specified initial conditions or boundary conditions.
The Green's function of this equation is defined as the solution $G(\mathbf{x}, \mathbf{y})$, of the equation

\begin{equation} \label{eq:eq2}
[ \nabla^2 G(\mathbf{x}, \mathbf{y}) + k_0^2 G(\mathbf{x}, \mathbf{y}) = -\delta(\mathbf{x} - \mathbf{y}). ]\end{equation}

The solution to (\ref{eq:eq2}) is then given by 

\begin{equation} \label{eq:eq3}[ u_\text{ind}(\mathbf{x}) = \int_{\mathbf{y} \in \mathbb{R}^n} G(\mathbf{x}, \mathbf{y}) f_\text{ind}(\mathbf{y}) \df{\mathbf{y}}.\end{equation}

The interesting cases are the 2D and 3D case. We will first focus on the 2D case. The Green's function is then given by

\begin{equation} \label{eq:eq4}[ G(\mathbf{x}, \mathbf{y}) = \frac{\imath}{4} H_0^{(1)}(k_0 \|\mathbf{x} - \mathbf{y}\|) = -\frac{1}{4} Y_0(k_0 \|\mathbf{x} - \mathbf{y}\|) + \frac{\imath}{4} J_0(k_0 \|\mathbf{x} - \mathbf{y}\|).  ]\end{equation}

In the above equation, the $H_0$ , $J_0$ and $Y_0$ are defined as the Henkel's functions and can be further researched at : \url{http://amcm.pcz.pl/get.php?article=2012_1/art_06.pdf}

\subsection{Helmholtz equation}

The simplest model we can use is the acoustic Helmholtz equation. We use a scalar pressure field $u(\mathbf{x})$ and the domain is modeled using $\chi(\mathbf{x})$. and is called the contrast and can be directly related to the wave speed at that point in the domain. Mathematically the equation has the form:

\begin{equation} \label{eq:eq5}
\nabla^2 u(\mathbf{x}) + k(\mathbf{x})^2 u(\mathbf{x}) = -f_{\text{ext}}(\mathbf{x}).
\end{equation} 

The wave number $k$ is given by $k = \frac{\omega}{c}$ where $\omega$ is the angular frequency and c is the acoustic wave velocity of the true medium.  We split the pressure field into $u(\mathbf{x}) = u_0(\mathbf{x}) + u_{\text{ind}}(\mathbf{x})$, where $u_0(\mathbf{x})$ is defined as the field given by the background velocity and external sources,

\begin{equation} \label{eq:eq6}
\nabla^2 u_0(\mathbf{x}) + k_0^2 u_0(\mathbf{x}) = -f_{\text{ext}}(\mathbf{x}).
\end{equation} 

Substituting in (\ref{eq:eq6}) results in

\begin{equation} \label{eq:eq7}
\nabla^2 u_\text{ind}(\mathbf{x}) + k_0^2 u_\text{ind}(\mathbf{x}) = -f_\text{ind}(\mathbf{x}),
\end{equation} 

with $f_\text{ind}(\mathbf{x}) = k_0^2 \chi(\mathbf{x}) u(\mathbf{x})$ the induced source term.


\subsection{The Contrast function}

The contrast function is defined as: 

\begin{equation} \label{eq:eq8}\chi(\mathbf{x}) = 1 - \left(\frac{c_0(\vec{x})}{c(\vec{x})} \right)^2. \end{equation} 

It depends on the difference between a known background medium $c_\text{0}(\vec{x})$ and the true, but unknown, subsurface model $c(\vec{x})$. The total field on the right-hand side in equation \ref{eq:eq1} is dependent on the contrast , because it contains the interaction between all subsurface scatterers. Then it follows that there is a nonlinear relationship between the subsurface properties and the measured seismic data.

Notice that the contrast is generally unknown, and will be approximated using an iterative scheme. During each step the induced source is considered constant and known so we basically solve the same equation as (\ref{eq:eq3}) each step.

\subsection{The Conjugate Gradient Scheme}

In the inversion scheme, we try to minimise the difference between the measured data $p_\text{data}$ and the modelled data that is obtained using the currently best estimate of the contrast function and the fixed total field. 

The residual between the measured and modelled data is obtained as: 

\begin{equation} \label{eq:eq9} r(\xr, \xs, \omega) = p_{\text{data}}(\xr, \xs, \omega) - \left[\mathcal{K}_\chi \right](\xr, \xs, \omega), \end{equation} 

with

\begin{equation} \label{eq:eq10} \left[\mathcal{K}_\chi \right](\xr, \xs, \omega) = \int \mathcal{G}(\xr, \x, \omega) p_\text{tot}(\x, \xs, \omega) \chi(\x) \df{\x} \end{equation} 

a linear operator in $\chi$. 

The error functional is equal to

\begin{equation} \label{eq:eq11} F(\chi) = \eta \int |r(\xr, \xs, \omega)|^2 \df{\mathbf{x}_\text{s}} \df{\xr} \df{\omega},\end{equation} 

with

\begin{equation} \label{eq:eq12} \eta^{-1} = \int | p_\text{data}(\xr, \xs, \omega) |^2 \df{\xs} \df{\xr} \df{\omega}, \end{equation} 

so that for $\chi = 0$ we have $F = 1$. Notice the implicit dependency on $\chi$.

We want to find a sequence of contrast functions, $\chi^{(n)}(\vec{x}), n = 1,2,...,$ in which error functional decreases with increasing iterations. Therefore, after each iteration the contrast function is updated as: 

\begin{equation} \label{eq:eq13} \chi^{(n)}(\vec{x}) =  \chi^{(n-1)}(\vec{x}) + \alpha_n\zeta_n(\vec{x}) \end{equation} 

Here, the step size of the update is determined by the parameter $\alpha_n$ while the update directions are conjugate gradient directions given by

\begin{equation} \label{eq:eq14}\zeta_1(\vec{x}) = g_1(\vec{x}) ,\zeta_n(\vec{x}) = g_n(\vec{x}) + \gamma_n\zeta_{n-1}(\vec{x}) \end{equation} 

The functional derivative w.r.t. $\chi$ in direction $\mathbf{d}$ of the error functional is equal to

\begin{eqnarray*}
\partder{F(\mathbf{\chi}, \mathbf{d})}{\mathbf{\chi}} & = & \lim_{\epsilon \rightarrow 0} \frac{F(\mathbf{\chi} + \epsilon \mathbf{d}) - F(\mathbf{\chi})}{\epsilon} \\
& = & \lim_{\epsilon \rightarrow 0} \frac{\eta}{\epsilon} \int \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right] - \epsilon \left[\mathcal{K}_\mathbf{d} \right] \right) \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right] - \epsilon \left[\mathcal{K}_\mathbf{d} \right] \right)^{\dagger} - \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right] \right) \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right] \right)^{\dagger} \df{\xs} \df{\xr} \df{\omega} \\
& = & -\lim_{\epsilon \rightarrow 0} \frac{\eta}{\epsilon} \int \epsilon \left[ \left[\mathcal{K}_\mathbf{d} \right] \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right]  \right)^{\dagger} + \left[\mathcal{K}_\mathbf{d} \right]^{\dagger} \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right] \right) \right] - \epsilon^2 \left[\mathcal{K}_\mathbf{d} \right] \left[\mathcal{K}_\mathbf{d} \right]^{\dagger} \df{\xs} \df{\xr} \df{\omega} \\
& = & -2 \eta \int \real{\left[\mathcal{K}_\mathbf{d} \right] \left(p_{\text{data}} - \left[\mathcal{K}_\chi \right]  \right)^{\dagger}} \df{\xs} \df{\xr} \df{\omega} \\
& = & -2 \eta \int \real{\left[\mathcal{K}_\mathbf{d} \right](\xr, \xs, \omega)^{\dagger} r (\xr, \xs, \omega)} \df{\xs} \df{\xr} \df{\omega}
\end{eqnarray*}

For the discrete $\mathcal{K}$ operator the integrand will have the form

\begin{equation} \label{eq:eq15} g_n(\vec{x}) = \eta \real{[\mathcal{K}^\star\mathbf{r}_{n-1}](\vec{x})} \end{equation} 

where the $\star$ denote element wise multiplication per row and Re denotes that only the real part will be used. 
The adjoint operator $[\mathcal{K}^\star\mathbf{r}_{n-1}]$ can be seen as a backprojection operator that maps the residual between measured data and modelled data from the surface domain to its associated location in the scattering domain.

In our conjugate gradient scheme we make use of the Polak-Ribi$\grave{e}$re direction,

\begin{equation} \label{eq:eq16} \gamma_n = \frac{\int g_n(\vec{x})[g_n(\vec{x})-g_{n-1}(\vec{x})]d(\vec{x})}{\int g_{n-1}(\vec{x}) g_{n-1}(\vec{x})d(\vec{x})} \end{equation} 

The optimal step size is found from the minimisation of cost functional equation, by setting the derivative equal to zero. Consequently the optimal step size becomes:

\begin{equation} \label{eq:eq17} \alpha_n = \frac {\real {\int \int \int r^{\star}_{n-1}(\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)[\mathcal{K} \zeta_n](\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)d\vec{x_s}d\vec{x_r}d\omega}}{\int \int \int \mid[\mathcal{K} \zeta_n](\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) \mid^2 d\vec{x_s}d\vec{x_r}d\omega} \end{equation} 

To initialise the conjugate gradient scheme, we assume, $\chi^0 (\vec{x}) = 0$, leading to $r_0(\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) = p_data(\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)$. Therefore, we find the gradient as :

\begin{equation} \label{eq:eq18} g_1(\vec{x}) = \eta \real{[\mathcal{K}^\star p_\text{data}](\vec{x})} \end{equation} 

and we get the first update parameter as :

\begin{equation} \label{eq:eq19} \alpha_1 = \frac {\real {\int \int \int p^{\star}_\text{data}(\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)[\mathcal{K} g_1](\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)d\vec{x_s}d\vec{x_r}d\omega}}{\int \int \int \mid[\mathcal{K} g_1](\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) \mid^2 d\vec{x_s}d\vec{x_r}d\omega} \end{equation} 


\subsection{Multiplicative Regularisation}

Since all seismic data contains some form of noise, the inversion process needs to be stabilised. Therefore, the CG scheme is extended in a way that it contains a multiplicative regularisation factor. 

The error functional $\mathcal{F}^{tot}$ becomes a product of the original error functional and a newly introduced regularisation factor $\mathcal{F}^{reg}$:

\begin{equation} \label{eq:eq20} \mathcal{F}^{tot}_n = \mathcal{F}^{data}_n \mathcal{F}^{reg}_n \end{equation} 

The following weighting function is used:

\begin{equation} \label{eq:eq21} b_n^{2} = (\int_{\vec{x}} d\vec{x})^{-1} (\mid\nabla\chi^{n-1}\mid^2 + \delta_{n-1}^2)^{-1} \end{equation} 

In the above equation, the $\delta_{n}^2$ is the steering factor and can be defined as:

\begin{equation} \label{eq:eq22} \delta_{n}^2 = (\int_{\vec{x}} d\vec{x})^{-1} \int_{\vec{x}} \mid\nabla\chi^{n-1}\mid^2 d\vec{x} \end{equation} 

The new total cost functional then becomes a sum of two second order polynomials:

\begin{equation} \label{eq:eq23} \mathcal{F}^{tot}_n = (\mathcal{A}_2\alpha^{2}_n + \mathcal{A}_1\alpha_n +\mathcal{A}_0)(\mathcal{B}_2\alpha^{2}_n + \mathcal{B}_1\alpha_n + \mathcal{B}_0) \end{equation} 

in which the constants are given by:

\begin{equation} \label{eq:eq24} \mathcal{A}_2 = \eta \int \int \int \mid \mathcal{K} \zeta_n \mid^2 d\vec{x_s}d\vec{x_r}d\omega \end{equation} 

\begin{equation} \label{eq:eq25} \mathcal{A}_1 = -2 \eta \real{\int \int \int r^{\star}_{n-1} \mid \mathcal{K} \zeta_n \mid d\vec{x_s}d\vec{x_r}d\omega} , \hat{E} \end{equation} 

\begin{equation} \label{eq:eq26} \mathcal{A}_0 = \eta \int \int \int \mid r_{n-1} \mid^2 d\vec{x_s}d\vec{x_r}d\omega =  \mathcal{F}^{data}_{n-1} , \hat{E} \end{equation} 

\begin{equation} \label{eq:eq27} \mathcal{B}_2 = \mid \mid b_n \nabla \zeta_n \mid \mid^{2}_D , \hat{E} \end{equation} 

\begin{equation} \label{eq:eq28} \mathcal{B}_1 = 2 < b_n \nabla\chi^{n-1}, b_n \nabla \zeta_n >_D, \hat{E} \end{equation} 

\begin{equation} \label{eq:eq29} \mathcal{B}_0 = \mid \mid b_n \nabla \chi^{n-1} \mid \mid^{2}_D + \delta^{2}_{n-1} \mid \mid b_n \mid \mid^{2}_D \end{equation} 

\subsection{Nonlinear field update based on the domain equation}

Initially, the subsurface properties are unknown  and the very first inversion is based on the assumption that wavefield propagation occurs in smooth non-scattering background medium only. Using an approximate smooth property model of the subsurface immediately tells us that the wavefield propagation in such an approximate medium cannot be exact and that for exact results we should make the wavefields consistent with the currently best estimate of the true medium. For this reason we assume $p_{tot} \approx p_0$.

Since the output of linear full waveform inversion is a property model, we do
not only obtain structural information but also a first order approximation of the subsurface properties at every grid point in the inversion domain. We can now use this property model to update the total field by solving the domain equation with in principle any suitable numerical method. Therefore, we iteratively build up the total fields as a sum of the background field and a number of basis functions:

\begin{equation} \label{eq:eq30} \phi_n (\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) = \int_{\vec{x}\in D} \mathcal{G} (\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega)\partial \mathcal{W}_n d\vec{x}' \end{equation} 

And the incremental contrast sources $\partial \mathcal{W}_n$ are given by:

\begin{equation} \label{eq:eq31} \partial \mathcal{W}_1 = \chi^{(1)} p^{0}_{tot} , \mathcal{W}_n = \chi^{(n)} p^{n-1}_{tot} - \chi^{(n-1)} p^{n-2}_{tot}, n > 1. \end{equation} 

The weighting factors are then determined and $p_tot$ is updated according to the equation: 

\begin{equation} \label{eq:eq32} p^{(N)}_{tot} (\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) =  p_0 (\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) + \sum\limits_{N=1}^N \alpha^{(N)}_n (\mathbf{x_\text{s}},\omega) \phi_n (\mathbf{x_\text{r}},\mathbf{x_\text{s}},\omega) \end{equation} 

\section{Computational Model}
The message passing interface (MPI) is a standardized means of exchanging messages between multiple computers running a parallel program across distributed memory.

In parallel computing, multiple computers - or even multiple processor cores within the same computer - are called nodes.  Each node in the parallel arrangement typically works on a portion of the overall computing problem. The challenge then is to synchronize the actions of each parallel node, exchange data between nodes and provide command and control over the entire parallel cluster. The message passing interface defines a standard suite of functions for these tasks.

For the FWI, the user sets in the input parameters, if GPU or CPU should be used. This is already checked in the beginning of the code and the appropriate functions corresponding to each are used. Further, the user also sets whether the frequency distribution should be group or alternate. This means that instead of splitting calculations over frequency chunks, split them alternatively over frequency for a better load balancing. 


\section{Code Algorithm}

The Code Algorithm is complicated and can be divided into the mathematical functions and the computational functions. 

For the mathematical functions, please refer to the FWI.vpp. It explains the main.cpp and the classes defined for this project. The main function basically creates the objects required for the inversion and then called the inversion cpu.h function which performs the main tasks. A high level representation of the main.cpp can be seen in Figure \ref{fig:fig3}.

\begin{figure}
\centering
 \includegraphics[scale=0.75]{main.jpg}
  \caption{High Level activity diagream for main.cpp}
  \label{fig:fig3}
\end{figure}


\subsection{Input parameters}

The input parameters can be defined by running the GUI.py file. It generates a GUI where input parameters can be set.

The inputs for the program are as follows:
\begin{enumerate}
    \item int nxt: No. of cells in x (needs to be a multiple of 32 for GPU)
    \item int nzt: No. of cells in y (needs to be a multiple of 32 for GPU)
    \item int nSrct: No. of sources and receivers
    \item int nFreq\_Total: No. of Frequencies
    \item int calc\_alpha: 1 to calculate alpha in CG scheme, 0 otherwise
    \item int n\_max: Max outer loop iterations
    \item int n\_iter1: Max iterations for conjugate gradient scheme
    \item int n\_iter2: Max p\_total iterations
    \item int do\_reg: Perform the multiplicative Regularization
    \item double F\_min1: Minimum Frequency
    \item double F\_max1: Maximum Frequency
    \item int freq\_dist\_group: 1 for group distribution of frequency, 0 for alternate distribution
    \item int nFreq\_input: number of frequencies per processor
    \item int gpu: 1 for GPU, otherwise 0 for CPU
\end{enumerate}

\subsection{main.cpp}

A high level representation of the main.cpp can be viewed in the FWI.vpp as a UML diagram. 
\newline

The main.cpp initialises the MPI functions responsible for parallel computations. Frequency distribution group and alternate are determined here and depending on the user input, the objects are created. Further, the main function creates the objects for the temple inversion and calls the appropriate functions as seen in FWI\_temple.

\subsection{temple\_inversion}

The main part of the code can be seen in the temple\_inversion. Over here, the Green's functions and created and the mathematical model detailed in section 2 is executed. A brief explanation of the functions can be seen as follows:
 
\subsubsection{createGreens()}

This function creates an array of Green's functions of the  Helmholtz equations. It is called from the Inversion class and refers to the equation \ref{eq:eq7}

\subsubsection{CreateP0()}
$p_0$ is the field calculated with the known contrast and due to the explanation given in section 2.6

\subsubsection{createTotalField()}

After the initial approximation, first iterative $p_{tot}$ is calculated here. This is done by calling the function calcfield(). In this function, the equations defined in section 2.5 are calculated. At first the incremental contrast sources are defined according to equation \ref{eq:eq31} and then the $\phi_n$ is constructed. Based on this \ref{eq:eq32} is constructed. This step concludes the forward modelling step.
\newline

Based on the input parameters, alpha is used if alpha is 1 and is not used if it is set to 0.

\subsubsection{calculateData()}
Once the total field $p_{tot}$ is obtained, the $p_{data}$ is calculated according to \ref{eq:eq1}. 

\subsubsection{Reconstruct()}
The reconstruct function might be the most important function of the code. The code runs in an iterative loop to minimise the residuals. According to tolerance values determined by the user and the max number of iterations, the residuals are minimised in order to obtain $p_{data}$. Once the residuals are minimised below the tolerance level, the final model is obtained.
\newline

The Conjugate Gradient scheme detailed in section 2.4 is coded here.

\subsubsection{MakeFigure()}

Finally, the MakeFigure() function is called which calls a python script to generate the figures.

\section{How to use the FWI}

This section details a step by step process to use the FWI. 


The development tools that need to be installed are:
\begin{enumerate}
    \item sudo apt-get install git  $\backslash\backslash$For checking out the repositories
    \item sudo apt-get install qt5-default  $\backslash\backslash$For QtCreator and qmake reuired for building
    \item sudo apt-get install g++   $\backslash\backslash$Required for compiling
    \item sudo apt-get install mpich   $\backslash\backslash$Needed during Qmake
\end{enumerate}

For the OpenCL:
\begin{enumerate}
    \item sudo apt-get install opencl-headers
    \item sudo apt-get install ocl-icd-libopencl1
    \item sudo apt-get install ocl-icd-opencl-dev
\end{enumerate}


For the Eigen libraries:
\begin{enumerate}
    \item sudo apt-get install libeigen3-dev
\end{enumerate}


For the MakeFigure function and GUI:

\begin{enumerate}
    \item sudo apt-get install python2.7-dev
    \item sudo apt-get install python2.7
    \item sudo apt-get install python-tk 
    \item sudo apt-get install python-numpy 
    \item sudo apt-get install python-matplotlib 
\end{enumerate}

Next, the repository needs to be checked out:
\newline

git clone -o redmine https://git.alten.nl/parallelized-fwi.git
\newline
git checkout docs-libraires-getting-started
\newline

Further, to build the project, first create a folder titled build-try\_qt-Desktop-Release and then:
\newline

mkdir Build
\newline
cd Build
\newline
qmake ../
\newline
make -j4
\newline
try\_qt.pro

\section{Results and Analysis}

The example chosen for the FWI code is the logo of the Delphi reserah consortium. The logo includes a greek temple consisting of four major
pillars under a triangularly shaped roof, as shown in Figure \ref{fig:fig4}.Additionally we added a layer below the temple to represent the basement. The whole structure is embedded in a homogeneous background with a constant acoustic velocity of c = 2000 m/s. The temple and the basement have a constant velocity.
The Results obtained from running the FWI code can be seen in the following figures:

\begin{figure}
\centering
 \includegraphics[scale=0.75]{Chi_est_it00.png}
  \caption{Chi estimation Result 1}
  \label{fig:fig4}
 \includegraphics[scale=0.75]{Chi_est_it01.png}
  \caption{Chi estimation Result 2}
  \label{fig:fig5}
\end{figure}

\begin{figure}
\centering
 \includegraphics[scale=0.75]{Chi_est_it02.png}
  \caption{Chi estimation Result 3}
  \label{fig:fig6}
 \includegraphics[scale=0.75]{Chi_est_it03.png}
  \caption{Chi estimation Result 4}
  \label{fig:fig7}
\end{figure}

\begin{figure}
\centering
 \includegraphics[scale=0.75]{Chi_est_it04.png}
  \caption{Chi estimation Result 5}
  \label{fig:fig8}
\end{figure}







\end{document}
